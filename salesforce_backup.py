# -*- coding: utf-8 -*-
"""salesforce-backup.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w-OnUhvkApypxFjuvUA9blsIbQ2IzJrB
"""

pip install simple_salesforce

# this is the FINAL CODE

import json
import pandas as pd
from simple_salesforce import Salesforce, SalesforceLogin
import os
import datetime
import requests
import base64

# Load Salesforce login details
username = 'rahulfatnani9@mindful-narwhal-38mkxl.com'
password = 'Rahul@1234'
security_token = '91GtNAAHM6k43yrmIIPSv9G1'
domain = 'login'

# Log in to Salesforce
session_id, instance = SalesforceLogin(username=username, password=password, security_token=security_token, domain=domain)
sf = Salesforce(instance=instance, session_id=session_id)

# Get a list of all objects in the org
objects_list = sf.describe()['sobjects']

# Filter out non-queryable and special event objects
filtered_objects = [
    obj for obj in objects_list
    if obj['queryable'] and not obj['name'].endswith(('ChangeEvent', 'History', 'Feed', 'Share', 'Log'))
]

# Create a backup folder if it doesn't exist
backup_folder = 'salesforce_backup'
if not os.path.exists(backup_folder):
    os.makedirs(backup_folder)

# Get current date for filename
date_str = datetime.datetime.now().strftime("%Y-%m-%d")

# Function to convert Unix timestamps to Salesforce-compatible date format
def convert_unix_to_salesforce_date(value):
    try:
        # Check if value is a number and in Unix timestamp range
        if isinstance(value, (int, float)) and value > 1e12:
            # Convert from Unix timestamp (milliseconds) to date
            dt = datetime.datetime.utcfromtimestamp(value / 1000.0)
            return dt.strftime('%Y-%m-%dT%H:%M:%SZ')  # Salesforce date format
        return value
    except Exception as e:
        return value

# Function to check if object has compound fields
def has_compound_fields(object_name):
    fields = sf.__getattr__(object_name).describe()['fields']
    compound_fields = [field for field in fields if field['compoundFieldName'] is not None]
    return len(compound_fields) > 0

# Function to query Salesforce using Bulk API and return a DataFrame
def query_all_records(object_name):
    try:
        # Describe object to get available fields
        fields = [field['name'] for field in sf.__getattr__(object_name).describe()['fields']]
        # Create the SOQL query
        soql_query = f"SELECT {', '.join(fields)} FROM {object_name} LIMIT 10000"  # Limit for demo purposes

        # Query the object
        data = sf.bulk.__getattr__(object_name).query(soql_query)

        # Convert records to DataFrame
        df_records = pd.DataFrame(data)
        if 'attributes' in df_records.columns:
            df_records.drop('attributes', axis=1, inplace=True)

        # Convert Unix timestamps to Salesforce date format
        for column in df_records.columns:
            df_records[column] = df_records[column].apply(convert_unix_to_salesforce_date)

        return df_records
    except Exception as e:
        print(f"Failed to backup {object_name}: {e}")
        return pd.DataFrame()

# Function to query Salesforce using REST API (for objects with compound fields like Account)
def query_via_rest(object_name):
    try:
        # Describe object to get available fields
        fields = [field['name'] for field in sf.__getattr__(object_name).describe()['fields']]
        # Create the SOQL query
        soql_query = f"SELECT {', '.join(fields)} FROM {object_name} LIMIT 1000"  # Reduce limit for REST API

        # Query the object using REST API
        data = sf.query_all(soql_query)['records']

        # Convert records to DataFrame
        df_records = pd.DataFrame(data)
        if 'attributes' in df_records.columns:
            df_records.drop('attributes', axis=1, inplace=True)

        # Convert Unix timestamps to Salesforce date format
        for column in df_records.columns:
            df_records[column] = df_records[column].apply(convert_unix_to_salesforce_date)

        return df_records
    except Exception as e:
        print(f"Failed to backup {object_name}: {e}")
        return pd.DataFrame()

# Function to upload a file to Salesforce ContentVersion
def upload_to_salesforce(file_path, file_name):
    try:
        # Open and read the file
        with open(file_path, 'rb') as f:
            file_content = f.read()

        # Encode the file content in base64 (required by Salesforce)
        file_base64 = base64.b64encode(file_content).decode('utf-8')

        # Create a new ContentVersion record
        content_version = {
            'Title': file_name,
            'PathOnClient': file_name,
            'VersionData': file_base64
        }

        # Send the POST request to create the ContentVersion record
        result = sf.ContentVersion.create(content_version)

        if result.get('id'):
            print(f"File {file_name} successfully uploaded to Salesforce ContentVersion.")
        else:
            print(f"Failed to upload {file_name} to Salesforce.")
    except Exception as e:
        print(f"Error uploading {file_name}: {e}")

# Loop through all filtered objects and back up the data
for obj in filtered_objects:
    object_name = obj['name']
    print(f"Extracting data for {object_name}...")

    # Use REST API for objects with compound fields, Bulk API for others
    if has_compound_fields(object_name) or object_name == 'ContentVersion':
        df = query_via_rest(object_name)
    else:
        df = query_all_records(object_name)

    # Save the data to a CSV file if not empty
    if not df.empty:
        filename = f'{backup_folder}/{object_name}_Backup_{date_str}.csv'
        df.to_csv(filename, index=False)
        print(f"Backup saved for {object_name} to {filename}")

        # Upload the file to Salesforce
        try:
            upload_to_salesforce(filename, f'{object_name}_Backup_{date_str}.csv')
        except Exception as e:
            print(f"Failed to upload {filename} to Salesforce: {e}")
    else:
        print(f"No data available for {object_name}.")

print("Backup completed.")